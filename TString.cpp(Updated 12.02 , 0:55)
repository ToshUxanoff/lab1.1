#include "stdafx.h"
#include "TString.h"
int Strlen(const char* str) 
{
	int len = 0;
	for (int i = 0; str[i] != 0; i++)
	{
		len++;
	}

	return len;
}
char* Strcpy(char*d, const char* s)
{
	char* start = d;
	while (*d++ = *s++)
	{

	}
	return start;
}
	//Method SIZE//
	size_t TString::Size() const
	{
		int len = 0;
		for (int i = 0; this->Data[i] != 0; i++)
		{
			len++;
		}

		return len;
	}

	//default ctor//
	TString::TString()
	{
		char* strdef = "Default String";
		Data = new char[Strlen(strdef) + 1];
		Strcpy(Data, strdef);
	}
	//user ctor char*//
	TString::TString(const char * str1)
	{
		Data = new char[Strlen(str1) + 1];
		Strcpy(Data, str1);

	}
	//copy ctor//
	TString::TString(const TString& object)

	{
		Data = new char[Strlen(object.Data) + 1];
		Strcpy(Data, object.Data);
	}

	//dtor//
	TString::~TString()
	{
		delete[] Data;
	}
	TString& TString:: operator=(const TString& object)
	{
		if (this != &object)
		{
			delete[]Data;
			Data = new char[Strlen(object.Data) + 1];
			strcpy(Data, object.Data);
		}
		else
		{
			std::cout << "Self Assignment" << std::endl;;
		}
		return *this;
	}
	TString& TString::operator+=(const TString& object)
	{
		int size = Size();
		char * str_t = new char[Size()];

		for (int i = 0; i < Strlen(str_t); i++)
		{
			str_t[i] = this->Data[i];
		}

		delete this->Data;
		this->Data = new char[Strlen(str_t) + Strlen(object.Data)];
		this->Data[Strlen(str_t) + Strlen(object.Data)] = '\0';
		for (int i = 0; i < Strlen(str_t); i++)
		{
			this->Data[i] = str_t[i];
		}
		for (int j = 0; j < Strlen(object.Data); j++)
		{
			this->Data[size + j] = object.Data[j];
		}
		return *this;
	}
	TString operator+(const TString & a, const TString & b)
	{
		int Size_A = Strlen(a.Data);
		int Size_B = Strlen(b.Data);
		char* str;
		str = new char[Size_A + Size_B];
		for (int i = 0; i < Size_A; i++)
		{
			str[i] = a.Data[i];
		}
		for (int j = 0; j < Size_B; j++)
		{
			str[Size_A + j] = b.Data[j];
		}
		str[Size_A + Size_B] = '\0';
		return str;
	}
	bool TString::operator ==(const TString& object) const
	{
		for (int i = 0; i < Size(); i++)
		{
			if (this->Data[i] != object.Data[i])
			{
				return false;
			}
		}
		return true;
	}
	bool operator!=(const TString & a, const TString & b)
	{
		int x = 0;
		if (a.Data[0] == b.Data[0])
		{
			return false;
		}
		else
		{
			for (int i = 0; i < Strlen(a.Data); i++)
			{
				if (a.Data[i] == b.Data[i])
				{
					x++;
				}
			}

		}
		if (x == Strlen(a.Data))
		{
			return false;
		}
		else
		{
			return true;
		}
	}
	bool TString::operator < (const TString& object) const
	{
		return(Size() < Strlen(object.Data) ? true : false);
	}
	bool operator>(const TString & a, const TString & b)
	{
		return(Strlen(a.Data) > Strlen(b.Data) ? true : false);
	}
	char TString::operator[](size_t index) const
	{
		if (index > Size())
		{
			std::cout << "Error";
			return 0;
		}
		else
		{
			std::cout << "\n You want to found " << index << " symbol in this string: " << this->Data << "\n Founded Symbol: ";
			return this->Data[index];
		}

	}
	char& TString::operator[](size_t index)
	{
		if (index > Size())
		{
			std::cout << "Error";
			
		}
		else
		{
			return this->Data[index];
		}
	}
	//Replace func
	void TString::Replace(char oldSym, char newSym)
	{
		std::cout << "\nReplace Func. " << oldSym << " to " << newSym << ":\t";
		for (int i = 0; i < Size(); i++)
		{
			if (this->Data[i] == oldSym)
			{

				Data[i] = newSym;
			}
		}
	}
	bool TString::Empty() const
	{
			if (this->Data != "")
			{
				std::cout << "Not empty" << std::endl;
				return false;
			}
			else
			{
				std::cout << "Empty" << std::endl;
				return true;
			}
	}
	//TRIMS
	void TString::LTrim(char symbol)
	{

		bool find = false;
		int a = 0;
		char * str_new = new char[Size()];
		std::cout << "\nLtrim func: ";
		int i = 0;



		for (int i = 0; i < Size(); i++)
		{
			if (this->Data[i] == symbol)
			{
				a++;
			}
			else
			{
				break;

			}
		}
		int c = a;
		for (int i = 0; i < Size() - c; a++, i++)
		{
			str_new[i] = this->Data[a];
		}

		str_new[Size() - c] = '\0';
		this->Data = str_new;
	}
	void TString::RTrim(char symbol)
	{
		std::cout << "\nRtrim func: ";
		int size = Size();
		int a = 0;
		for (int i = 0; i < size + 1; i++)
		{
			int j = size - i;
			if (this->Data[j] != symbol)
			{
				a++;
				Data[j + 1] = '\0';
				if (a == 2)
				{
					break;
				}
			}

		}
	}
	//Find func
	size_t TString::Find(const TString& object) const
	{
		int ret = 0;
		int check = 0;
		for (int i = 0; i < Size(); i++)
		{
			if (this->Data[i] == object.Data[0])
			{
				check++;
				ret = i;
				for (int j = 1; j < Strlen(object.Data); j++)
				{
					i++;
					if (this->Data[i] == object.Data[j])
					{
						check++;
					}
					else
					{
						check = 0;
						break;
					}
				}
			}
		}
		if (check == Strlen(object.Data))
		{
			return ret;
		}
		else
		{
			return -1;
		}

	}
	
	std::ostream & operator<<(std::ostream &out, const TString & object)
	{
		out << object.Data;
		return out;
	}

